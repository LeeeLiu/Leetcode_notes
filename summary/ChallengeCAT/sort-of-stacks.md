
### 栈排序
>来源：[《程序员面试金典-第6版》10.3章节 3.5](https://weread.qq.com/web/reader/bf93256071a122bebf98d95k98d321b025d98dce83da05a)
1. 描述
    - 编写程序，对栈进行排序使`最小元素`位于栈顶。
    - 最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。
    - 该栈支持如下操作：push、pop、peek和isEmpty。
2. 解法一
    - 需要三个栈：实现初步的排序算法。搜索整个栈，找出最小元素，之后将其压入另一个栈。
    - 然后，在剩余元素中找出最小的，并将其入栈。
    - 这种做法实际上需要三个栈：s1为原先的栈，s2为最终排好序的栈，s3在搜索s1时用作缓冲区。要在s1中搜索最小值，我们需要弹出s1的元素，将它们压入缓冲区s3。
3. 解法二，需要两个栈：
    - 不需要反复搜索最小值，若要对s1排序，可以从s1逐一弹出元素，然后按顺序插入s2中。
    - 假设有如下两个栈，其中s2是“排序的”，s1则是未排序的。
        ![插图1](https://img-1300025586.cos.ap-shanghai.myqcloud.com/%E6%8F%92%E5%9B%BE1.png)
    - 从s1中弹出5时，我们需要在s2中找个合适的位置插入这个数。在这个例子中，正确位置是在s2元素3之上。
    - 怎样才能将5插入那个位置呢？我们可以先从s1中弹出5，将其存放在临时变量中。然后，将12和8移至s1（从s2中弹出这两个数，并将它们压入s1中），然后将5压入s2。
    ![插图2](https://img-1300025586.cos.ap-shanghai.myqcloud.com/%E6%8F%92%E5%9B%BE2.png)
    - 注意，8和12仍在s1中，这没关系。对于这两个数，我们可以像处理5那样重复相关步骤，每次弹出s1栈顶元素，将其放入s2中的合适位置。当然，我们可以将8和12直接从s2移至s1，因为这两个数都比5大，这些元素的“正确位置”就是放在5之上。我们不需要打乱s2的其他元素，当tmp为8或12时，下面代码中的第二个while循环不会执行。
4. 解法二：代码
    - 时间复杂度为O(N^2)，空间复杂度为O(N)。
    - 待排序的栈是S，升序排列的是R。
    - 把R中元素都pop出来，给S。这样S就是降序的了。
    ```
    void sort(stack<int> s) {
         stack<int> r;
         while(!s.empty()) {
           /* 把s中的每个元素有序地插入到r中 */
           int tmp = s.pop();
           while(!r.empty() && r.top() > tmp) {
              s.push(r.pop());
           }
           r.push(tmp);
        }
    
       /* 将r中元素复制回s */
        while (！r.isEmpty()) {
          s.push(r.pop());
        }
    }
    ```


5. 如果允许使用的栈数量不限，我们可以实现修改版的quicksort或mergesort。
    - 对于mergesort解法，我们可以再创建两个栈，并将这个栈分为两部分。我们会递归排序每个栈，然后将它们归并到一起并排好序，放回原来的栈中。注意，该解法要求每层递归都创建两个额外的栈。
    - 对于quicksort解法，我们会创建两个额外的栈，并根据基准元素（pivot element）将这个栈分为两个栈。这两个栈会进行递归排序，然后归并在一起，放回原来的栈中。
    - 与上一个解法一样，每层递归都会创建两个额外的栈。

