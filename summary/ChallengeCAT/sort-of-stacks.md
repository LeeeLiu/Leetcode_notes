
### 栈排序
>来源：《程序员面试金典-第6版》10.3章节  3.5
1. 描述
编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek和isEmpty。
2. 解法一
    - 需要三个栈：实现初步的排序算法。搜索整个栈，找出最小元素，之后将其压入另一个栈。
    - 然后，在剩余元素中找出最小的，并将其入栈。
    - 这种做法实际上需要三个栈：s1为原先的栈，s2为最终排好序的栈，s3在搜索s1时用作缓冲区。要在s1中搜索最小值，我们需要弹出s1的元素，将它们压入缓冲区s3。
3. 解法二，需要两个栈：
    - 不需要反复搜索最小值，若要对s1排序，可以从s1逐一弹出元素，然后按顺序插入s2中。
    - 假设有如下两个栈，其中s2是“排序的”，s1则是未排序的。
        ![插图1](https://img-1300025586.cos.ap-shanghai.myqcloud.com/%E6%8F%92%E5%9B%BE1.png)
    - 从s1中弹出5时，我们需要在s2中找个合适的位置插入这个数。在这个例子中，正确位置是在s2元素3之上。
    - 怎样才能将5插入那个位置呢？我们可以先从s1中弹出5，将其存放在临时变量中。然后，将12和8移至s1（从s2中弹出这两个数，并将它们压入s1中），然后将5压入s2。
    ![插图2](https://img-1300025586.cos.ap-shanghai.myqcloud.com/%E6%8F%92%E5%9B%BE2.png)
    - 注意，8和12仍在s1中，这没关系。对于这两个数，我们可以像处理5那样重复相关步骤，每次弹出s1栈顶元素，将其放入s2中的合适位置。当然，我们可以将8和12直接从s2移至s1，因为这两个数都比5大，这些元素的“正确位置”就是放在5之上。我们不需要打乱s2的其他元素，当tmp为8或12时，下面代码中的第二个while循环不会执行。
4. 解法二：代码
    - 时间复杂度为O(N^2)，空间复杂度为O(N)。
    ```
    1  void sort(Stack<Integer> s) {
    2     Stack<Integer> r = new Stack<Integer>();
    3     while(！s.isEmpty()) {
    4       /* 把s中的每个元素有序地插入到r中 */
    5       int tmp = s.pop();
    6       while(！r.isEmpty() && r.peek() > tmp) {
    7          s.push(r.pop());
    8       }
    9       r.push(tmp);
    10    }
    11
    12   /* 将r中元素复制回s */
    13    while (！r.isEmpty()) {
    14      s.push(r.pop());
    15    }
    16 }

    ```

5. 如果允许使用的栈数量不限，我们可以实现修改版的quicksort或mergesort。
    - 对于mergesort解法，我们可以再创建两个栈，并将这个栈分为两部分。我们会递归排序每个栈，然后将它们归并到一起并排好序，放回原来的栈中。注意，该解法要求每层递归都创建两个额外的栈。
    - 对于quicksort解法，我们会创建两个额外的栈，并根据基准元素（pivot element）将这个栈分为两个栈。这两个栈会进行递归排序，然后归并在一起，放回原来的栈中。
    - 与上一个解法一样，每层递归都会创建两个额外的栈。

