


### 120. 单词接龙
- 题型：单源-无权图-最短路（边的权重为1）
- [出处](https://www.lintcode.com/problem/word-ladder/description)
- 描述
    给出两个单词（start和end）和一个字典，找出从start到end的最短转换序列，输出最短序列的长度。
    变换规则如下：
    每次只能改变一个字母。
    变换过程中的中间单词必须在字典中出现。(起始单词和结束单词不需要出现在字典中)
    如果不存在这样的转换序列，返回0。
    所有单词具有相同的长度。
    所有单词只由小写字母组成。
    字典中不存在重复的单词。
    你可以假设 beginWord 和 endWord 是非空的，且二者不相同。
- 实现
```
class Solution {
public:
    int ladderLength(string &start, string &end, unordered_set<string> &dict) {
        //len：start到字典里每个单词的，转换长度。
        map<string, int>len;  
        for(auto word: dict)    len[word] = INT_MAX;  //初始化len

        //相差一个字符的单词，可视作一对邻接点。本题可视作：单源-无权图。（边的权重为1）
        queue<string>Q;
        for(auto w: dict)
        {
            if(w==start)
                {len[w] = 0;}
            if( dif(w, start)==1 )
            {
                Q.push(w);  //队列里先放进与start相差一个字符的单词w(可能不止一个，这里只放一个即可)
                len[w] = 1; //w和start距离是1（因为相差一个字符）                
            }
        }
        
        if(Q.size()<=dict.size() && dif(start,end)==1)
            return 2;
        
        // start和end，可以不在dict里出现。方便起见，将end插进dict里。
        dict.insert(end);
        len[end] = INT_MAX;
        string cur_word;    //保存队列里的头元素
        while(!Q.empty())
        {
            cur_word = Q.front(); //取队列头元素
            Q.pop();    //出队
            //在字典dict中找到与start只差一个字符(如果没有就return)
            //且未被收录(len[w]==0)的单词w
            //w入队
            for(auto w: dict)
            {
                if( dif(w, cur_word)==1 && len[w]==INT_MAX)
                {
                    len[w] = len[cur_word] +1;  //更新距离
                    //入队
                    Q.push(w);
                }
            }
        }
        
        return  len[end]==INT_MAX?  0:  len[end]+1;
    }

    int dif(string s1, string s2)
    {
        int d = 0, i;        
        for(i=0; i<s1.size(); i++)
        {
            if(s1[i]!=s2[i])
                d++;
        }
        return d;
    }
};
```