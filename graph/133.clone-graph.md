

### 133. å…‹éš†å›¾
1. æè¿°
    - å¯¹äº`æ— å‘`çš„`è¿é€š` å›¾ï¼Œç»™ä½ ä¸€ä¸ªèŠ‚ç‚¹çš„å¼•ç”¨ï¼Œè¯·ä½ è¿”å›è¯¥å›¾çš„ æ·±æ‹·è´ï¼ˆå…‹éš†ï¼‰ã€‚
    - æç¤ºï¼š
        - æ¯ä¸ªèŠ‚ç‚¹å€¼Â Node.val éƒ½æ˜¯å”¯ä¸€çš„ï¼Œ1 <= Node.val <= 100ã€‚        
        - ç”±äºå›¾æ˜¯`æ— å‘`çš„ğŸ‘‡
            + å¦‚æœèŠ‚ç‚¹ p æ˜¯èŠ‚ç‚¹ q çš„é‚»å±…ï¼Œé‚£ä¹ˆèŠ‚ç‚¹ q ä¹Ÿå¿…é¡»æ˜¯èŠ‚ç‚¹ pÂ çš„é‚»å±…ã€‚
            + æ— å‘å›¾æ˜¯ä¸€ä¸ªç®€å•å›¾ï¼Œæ²¡æœ‰é‡å¤çš„è¾¹ï¼Œä¹Ÿæ²¡æœ‰è‡ªç¯ã€‚
        - å›¾æ˜¯`è¿é€šå›¾`ï¼Œä½ å¯ä»¥ä»ç»™å®šèŠ‚ç‚¹è®¿é—®åˆ°æ‰€æœ‰èŠ‚ç‚¹ã€‚    
    - å®šä¹‰
        ```
        /*
        class Node {
        public:
            int val;
            vector<Node*> neighbors;
            
            Node() {
                val = 0;
                neighbors = vector<Node*>();
            }
            
            Node(int _val) {
                val = _val;
                neighbors = vector<Node*>();
            }
            
            Node(int _val, vector<Node*> _neighbors) {
                val = _val;
                neighbors = _neighbors;
            }
        };
        */
        ```


2. æ€è·¯
    - ç”±äºï¼šæ¯ä¸ª Node.val âˆˆã€1ï¼Œ100ã€‘ï¼Œä¸”æ¯ä¸ª Node.val å”¯ä¸€ã€‚
        + å®šä¹‰unordered_map<int, Node*> visit_clone
        + visit[Node.val, cloneNode] è¡¨ç¤º Node èŠ‚ç‚¹å·²è¢«è®¿é—®ï¼Œä¸”cloneNode æ˜¯ Node å¯¹åº”çš„å…‹éš†èŠ‚ç‚¹
    - DFS           
    - BFS
    
3. å®ç°
    - DFS
        ```
        class Solution {
        public:
            unordered_map<int, Node*>visit_clone;
            Node* dfs(Node* node){
                if(!node)
                    return node;
                // å¦‚æœå·²è®¿é—®ï¼Œç›´æ¥è¿”å›å…‹éš†èŠ‚ç‚¹
                if(visit_clone.count(node->val))
                    return visit_clone[node->val];
                // å¦‚æœæ²¡è®¿é—®ï¼Œæ ‡è®°è®¿é—®ï¼Œå¹¶ä¸”å…‹éš†èŠ‚ç‚¹
                visit_clone[node->val] = new Node(node->val);
                // å…‹éš†é‚»å±…èŠ‚ç‚¹
                for(auto n: node->neighbors){
                    // DFS é€’å½’
                    visit_clone[node->val]->neighbors.push_back( dfs(n) );
                }
                return visit_clone[node->val];
            }
            Node* cloneGraph(Node* node) {
                return dfs(node);
            }
        };
        ```      

    - BFS
        ```
        class Solution {
        public:
            Node* cloneGraph(Node* node) {
                if(!node)
                    return node;
                unordered_map<int, Node*>visit_cloneNode;
                // é˜Ÿåˆ—é‡Œï¼Œæ˜¯å…‹éš†ä¹‹å‰çš„èŠ‚ç‚¹
                queue<Node*>Q;
                Q.push(node);
                visit_cloneNode[node->val] = new Node(node->val);
                Node* cur;
                while(!Q.empty()){
                    cur = Q.front();
                    Q.pop();
                    // å…‹éš†é‚»å±…èŠ‚ç‚¹
                    for(auto n: cur->neighbors){
                        // å¦‚æœæ²¡æœ‰è®¿é—®ï¼Œæ ‡è®°ä¸ºè®¿é—®ï¼Œå¹¶ä¸”å…‹éš† é‚»å±…èŠ‚ç‚¹
                        if(!visit_cloneNode.count(n->val)){
                            Q.push(n);
                            visit_cloneNode[n->val] = new Node(n->val);
                        }                
                        visit_cloneNode[cur->val]->neighbors.push_back(visit_cloneNode[n->val]);                
                    }
                }
                return visit_cloneNode[node->val];
            }
        };
        ```