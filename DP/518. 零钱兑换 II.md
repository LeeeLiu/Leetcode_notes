

### 518. 零钱兑换 II
>描述：给定不同面额的硬币和一个总金额。
求解可以凑成总金额的硬币组合数。
假设每一种面额的硬币有无限个。 
>示例 1:
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
示例 2:
输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。
示例 3:
输入: amount = 10, coins = [10] 
输出: 1

1. 分析
    1. 确定状态
        - 找最后一步
        - 子问题
    2. 转移方程
        - `f[x] = Σ{ f[x-2], f[x-5], f[x-7] }`
        - f[x]表示，可以拼出X元的硬币`组合种类数`。
    3. 初始条件、边界情况
        - 边界情况。如果f[x]下标为非法值，比如负数，此时，无法用硬币拼出X元。
        - 初始值。这里f[0]=1。表示只有一种方案(不选择任何硬币)，能够拼凑出0元。        
    4. 计算顺序
        - 初始条件f[0]=1
        - 计算f[0], f[1], ... , f[27]    （这里是小->大）
        - 时间复杂度 3*27.

2. 实现
```
class Solution {
public:
    int change(int amount, vector<int>& coins) {        
        int n=coins.size(), i, j;
        int f[amount+1];
        //初始化
        f[0]=1;
        for(j=1; j<=amount; j++)
            f[j]=0;
        
        for(i=0; i<n; i++)  //按照硬币编号【0-> n-1】          
        {   for(j=1; j<=amount; j++)    //按照目标总金额，【1->amount】   
            {                                   
                if(j-coins[i]>=0 )  // j-coins[i]不能为负
                    f[j] = f[j] + f[j-coins[i]];  
                                    //f[j] = f[j-coins[0]],+ ..., + f[j-coins[n-1]]
            }
        }
         
        return f[amount];
    }
};
```