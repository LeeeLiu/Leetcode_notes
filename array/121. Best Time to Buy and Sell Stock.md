
### 121. Best Time to Buy and Sell Stock
>描述：现有一个数组，第i个数字表示买入或者卖出的股票价格。求在合适时机买入和卖出以后，最大利润是多少。
>Example 1:
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Not 7-1 = 6, as selling price needs to be larger than buying price.

1. 买入价格min_buy，卖出价格prices[i]。
    ```
    class Solution {
    public:
        int maxProfit(vector<int>& prices) {
            if(empty(prices))
                return 0;
            int min_buy=prices[0], max_sale;
            int max_profit = 0, i;
            for(i=0; i<prices.size(); i++)
            {
                min_buy = min(min_buy, prices[i]); //min_buy是prices数组全局最小值
                max_sale = prices[i]; //max_sale是依次遍历的每个prices元素（因为卖出价格要比买入价格高，且卖出价格索引i要在买入索引i之后）
                
                max_profit = max(max_profit, max_sale-min_buy);
            }
            return max_profit;
        }
    };
    ```
2. 如果数组元素是相邻price的差，则可以使用最小子列和的思路（见53题）。
```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(empty(prices))
            return 0;
        int i;
        int res;
        vector<int> dif;
        int sum=0;
        int dif_value;
        
        //取差分数组序列dif
        dif.push_back(0);
        for(i=1; i<prices.size(); i++)
        {
            dif_value = prices[i]-prices[i-1];
            dif.push_back(dif_value);
        }
        
        // 在dif数组上，应用“53.最大子列和之Kadane's algorithm算法”
        res = 0;
        for(i=0; i<prices.size(); i++)
        {
            sum = max(dif[i], sum+dif[i]);
            res = max(res, sum);
        }
        
        return res;
    }
};
```